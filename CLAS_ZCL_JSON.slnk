<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="ZCL_JSON" VERSION="1" LANGU="P" DESCRIPT="JSON" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class

define skip_to_next_character.
  while position &lt; length and
        json+position(1) na &apos;&quot;,:{}[]&apos;.
    add 1 to position.
  endwhile.
end-of-definition.</localMacros>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="CR" VERSION="1" LANGU="P" DESCRIPT="CR (13)" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="C" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="INCLUDE_EMPTY_VALUES" VERSION="1" LANGU="P" DESCRIPT="Incluir elementos vazios (sem valor/iniciais)." EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTVALUE="&apos;X&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="LF" VERSION="1" LANGU="P" DESCRIPT="LF (10)" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="C" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="LOWERCASE_NAMES" VERSION="1" LANGU="P" DESCRIPT="Nomes em minúsculas" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTVALUE="&apos;X&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="PRETTY_PRINT" VERSION="1" LANGU="P" DESCRIPT="Devolver JSON formatado com indentação." EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON" CMPNAME="USE_CONVERSION_EXITS" VERSION="1" LANGU="P" DESCRIPT="Utiliza conversão de campos ABAP" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTVALUE="&apos;X&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="FLAG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <method CLSNAME="ZCL_JSON" CMPNAME="CALL_CONVERSION_EXIT" VERSION="1" LANGU="P" DESCRIPT="Chama rotina de conversão para valor" EXPOSURE="0" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="CALL_CONVERSION_EXIT" SCONAME="DIRECTION" VERSION="1" LANGU="P" DESCRIPT="Direção (1 = saída, 2 = entrada)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="DIRECTION"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="CALL_CONVERSION_EXIT" SCONAME="TYPE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="CALL_CONVERSION_EXIT" SCONAME="VALUE" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="CALL_CONVERSION_EXIT" SCONAME="RESULT" VERSION="1" LANGU="P" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <source>method call_conversion_exit.
    data: ddic_objects  type dd_x031l_table,
          function_name type string,
          cstr_value    type c length 255.
    field-symbols: &lt;ddic&gt; like line of ddic_objects.

    &quot;// Call conversion exit function
    type-&gt;get_ddic_object(
      receiving p_object = ddic_objects
      exceptions others = 8
    ).
    read table ddic_objects index 1 assigning &lt;ddic&gt;.
    if sy-subrc = 0 and &lt;ddic&gt;-convexit is not initial.
      cstr_value = value.
      if direction = 1.
        concatenate &apos;CONVERSION_EXIT_&apos; &lt;ddic&gt;-convexit &apos;_OUTPUT&apos;
          into function_name.
      else.
        concatenate &apos;CONVERSION_EXIT_&apos; &lt;ddic&gt;-convexit &apos;_INPUT&apos;
          into function_name.
      endif.
      try.
        call function function_name
          exporting
            input  = cstr_value
          importing
            output = result
          exceptions
            others = 8.
      catch cx_root.
      endtry.
    endif.
  endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="P" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CLASS_CONSTRUCTOR.
  &quot;// Initialize static attributes
  field-symbols &lt;x&gt; type x.

  assign cr to &lt;x&gt; casting. &lt;x&gt; = 13.
  assign lf to &lt;x&gt; casting. &lt;x&gt; = 10.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DATE_ISO_TO_SAP" VERSION="1" LANGU="P" DESCRIPT="Converte uma data ISO-8601 para o formato SAP" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DATE_ISO_TO_SAP" SCONAME="DATE" VERSION="1" LANGU="P" DESCRIPT="Data SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DATE_ISO_TO_SAP" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Data em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="DATS"/>
  <source>method DATE_ISO_TO_SAP.
  data: year(4) type n,
        month(2) type n,
        day(2) type n.

  &quot;// ISO-8601 allowed formats:
  &quot;//  YYYY-MM-DD or YYYYMMDD or YYYY-MM
  find regex &apos;(\d{4})-?(\d{2})-?(\d{2})?&apos; in date
    submatches year month day.
  if year is initial and
     month is initial and
     day is initial.
    return.
  endif.
  if day is initial.
    day = 1.
  endif.

  concatenate year month day into result.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DATE_SAP_TO_ISO" VERSION="1" LANGU="P" DESCRIPT="Converte uma data SAP para o formato ISO-8601" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DATE_SAP_TO_ISO" SCONAME="DATE" VERSION="1" LANGU="P" DESCRIPT="Data SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="DATS"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DATE_SAP_TO_ISO" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Data em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method DATE_SAP_TO_ISO.
  concatenate date(4) &apos;-&apos; date+4(2) &apos;-&apos; date+6(2) into result.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE" VERSION="1" LANGU="P" DESCRIPT="Decodifica uma string JSON para um objeto de dados novo" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Valor a ser preenchido" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <source>method DECODE.
  data: decode_string type string,
        decode_length type i,
        decode_pos type i.

  &quot;// Prepare decoding
  decode_string = json.
  condense decode_string.
  decode_length = strlen( decode_string ).
  decode_pos = 0.

  clear value.

  &quot;// Decode JSON string into value object
  decode_anything(
    exporting
      json = decode_string
      length = decode_length
    changing
      position = decode_pos
      value = value
  ).
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE_ANYTHING" VERSION="1" LANGU="P" DESCRIPT="Decodifica um objeto de dados genérico" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ANYTHING" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ANYTHING" SCONAME="LENGTH" VERSION="1" LANGU="P" DESCRIPT="Tamanho da string JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ANYTHING" SCONAME="POSITION" VERSION="1" LANGU="P" DESCRIPT="Posição do processamento" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ANYTHING" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Valor a ser preenchido" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>method DECODE_ANYTHING.
  data: name type string,
        string_value type string,
        has_name type flag.

  &quot;// Skip padding characters
  skip_to_next_character.
  check position &lt; length.

  &quot;// Member has a name?
  if json+position(1) = &apos;&quot;&apos;.
    has_name = &apos;X&apos;.
    decode_string(
      exporting
        json = json
        length = length
      changing
        position = position
        string = name
    ).
  endif.

  &quot;// Skip padding characters
  skip_to_next_character.
  check position &lt; length.

  &quot;// Check if this is a single value or an attribute
  if has_name = &apos;X&apos;.
    case json+position(1).
      when &apos;,&apos;.
        value = name.
        add 1 to position.
        return.
      when &apos;:&apos;.
        add 1 to position.
      when  &apos;]&apos; or &apos;}&apos;.
        value = name.
        return.
    endcase.
  endif.

  &quot;// Skip padding characters
  skip_to_next_character.
  check position &lt; length.

  &quot;// Decode member value
  case json+position(1).
    when &apos;&quot;&apos;. &quot;// begin string
      decode_field(
        exporting
          name = name
          json = json
          length = length
        changing
          position = position
          value = value
      ).

    when &apos;{&apos;.
      &quot;// begin object =&gt; structure
      decode_object(
        exporting
          name = name
          json = json
          length = length
        changing
          position = position
          value = value
      ).

    when &apos;[&apos;.
      &quot;// begin array =&gt; table
      decode_array(
        exporting
          name = name
          json = json
          length = length
        changing
          position = position
          value = value
      ).
  endcase.

  &quot;// Check if object/array has just ended
  skip_to_next_character.
  check position &lt; length.

  if json+position(1) na &apos;]}&apos;.
    add 1 to position.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" VERSION="1" LANGU="P" DESCRIPT="Decodifica um array JSON" EXPOSURE="0" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" SCONAME="LENGTH" VERSION="1" LANGU="P" DESCRIPT="Tamanho da string JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" SCONAME="POSITION" VERSION="1" LANGU="P" DESCRIPT="Posição do processamento" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_ARRAY" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Estrutura a ser preenchida" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>method DECODE_ARRAY.
  data: abap_name type string,
        typekind type c,
        dummy type table of syst,
        ld_line type ref to data.

  field-symbols: &lt;table&gt; type any table,
                 &lt;struct&gt; type any.

  abap_name = name. translate abap_name to upper case.
  describe field value type typekind.
  if typekind = cl_abap_typedescr=&gt;typekind_table.
    assign value to &lt;table&gt;.
  else.
    assign component abap_name of structure value to &lt;table&gt;.
    if sy-subrc &lt;&gt; 0.
      assign dummy to &lt;table&gt;.
    endif.
  endif.

  add 1 to position.

  &quot;// Decode member value
  while position &lt; length and
        json+position(1) &lt;&gt; &apos;]&apos;.

    create data ld_line like line of &lt;table&gt;.
    assign ld_line-&gt;* to &lt;struct&gt;.

    decode_anything(
      exporting
        json = json
        length = length
      changing
        position = position
        value = &lt;struct&gt;
    ).

    insert &lt;struct&gt; into table &lt;table&gt;.

    &quot;// Skip padding characters
    skip_to_next_character.
    check position &lt; length.
  endwhile.
  add 1 to position.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" VERSION="1" LANGU="P" DESCRIPT="Decodifica um campo JSON" EXPOSURE="0" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" SCONAME="LENGTH" VERSION="1" LANGU="P" DESCRIPT="Tamanho da string JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Valor a ser preenchido" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_FIELD" SCONAME="POSITION" VERSION="1" LANGU="P" DESCRIPT="Posição do processamento" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <source>method DECODE_FIELD.
  data: abap_name type string,
        str_value type string,
        type type ref to cl_abap_typedescr,
        relative_name type string.
  field-symbols: &lt;field&gt; type any.

  &quot;// Skip padding characters
  skip_to_next_character.
  check position &lt; length.

  &quot;// Decode field value
  decode_string(
    exporting
      json = json
      length = length
    changing
      position = position
      string = str_value
  ).

  abap_name = name. translate abap_name to upper case.
  assign component abap_name of structure value to &lt;field&gt;.
  if sy-subrc &lt;&gt; 0.
    return.
  endif.

  &quot;// Get type kind
  type ?= cl_abap_typedescr=&gt;describe_by_data( &lt;field&gt; ).

  &quot;// Timestamp? (becomes ISO-8601)
  relative_name = type-&gt;get_relative_name( ).
  if relative_name = &apos;TIMESTAMP&apos;.
    &lt;field&gt; = timestamp_iso_to_sap( str_value ).
  else.
    case type-&gt;type_kind.
        &quot;// Date fields (become ISO-8601)
        when cl_abap_typedescr=&gt;typekind_date.
          &lt;field&gt; = date_iso_to_sap( str_value ).

        &quot;// Time fields (become ISO-8601)
        when cl_abap_typedescr=&gt;typekind_time.
          &lt;field&gt; = time_iso_to_sap( str_value ).

      &quot;// Anything else gets the default SAP input conversion
      when others.
        &lt;field&gt; = str_value.
        if me-&gt;use_conversion_exits is not initial.
          call_conversion_exit(
            exporting direction = 2
                      type = type
                      value = str_value
            changing result = &lt;field&gt;
          ).
        endif.
    endcase.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" VERSION="1" LANGU="P" DESCRIPT="Decodifica um objeto JSON" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" SCONAME="LENGTH" VERSION="1" LANGU="P" DESCRIPT="Tamanho da string JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" SCONAME="POSITION" VERSION="1" LANGU="P" DESCRIPT="Posição do processamento" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_OBJECT" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Estrutura a ser preenchida" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>method DECODE_OBJECT.
  data: abap_name type string,
        dummy type syst.
  field-symbols: &lt;struct&gt; type any.

  if name is initial.
    assign value to &lt;struct&gt;.
  else.
    abap_name = name. translate abap_name to upper case.
    assign component abap_name of structure value to &lt;struct&gt;.
    if sy-subrc &lt;&gt; 0.
      assign dummy to &lt;struct&gt;.
    endif.
  endif.

  add 1 to position.

  &quot;// Decode member value
  while position &lt; length and
        json+position(1) &lt;&gt; &apos;}&apos;.

    decode_anything(
      exporting
        json = json
        length = length
      changing
        position = position
        value = &lt;struct&gt;
    ).

    &quot;// Skip padding characters
    skip_to_next_character.
    check position &lt; length.
  endwhile.
  add 1 to position.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="DECODE_STRING" VERSION="1" LANGU="P" DESCRIPT="Decodifica uma string JSON" EXPOSURE="0" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_STRING" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_STRING" SCONAME="LENGTH" VERSION="1" LANGU="P" DESCRIPT="Tamanho da string JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_STRING" SCONAME="POSITION" VERSION="1" LANGU="P" DESCRIPT="Posição do processamento" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="INT4"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="DECODE_STRING" SCONAME="STRING" VERSION="1" LANGU="P" DESCRIPT="Campo decodificado" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method decode_string.
  data: characters      type table of c,
        unicode_hexc(4) type c,
        unicode_hex(4)  type x.

  field-symbols: &lt;unicode_char&gt; type c.

  add 1 to position.
  while position &lt; length.
    case json+position(1).
      when &apos;\&apos;. &quot;// Escaped character
        add 1 to position.
        case json+position(1).
          when &apos;&quot;&apos;.
            append &apos;&quot;&apos; to characters.
          when &apos;\&apos;.
            append &apos;\&apos; to characters.
          when &apos;r&apos;.
            append cr to characters.
          when &apos;n&apos;.
            append lf to characters.
          when &apos;u&apos;.
            add 1 to position.
            unicode_hexc = json+position(4).
            translate unicode_hexc to upper case.
            unicode_hex = unicode_hexc.
            assign unicode_hex to &lt;unicode_char&gt; casting.
            append &lt;unicode_char&gt; to characters.
            add 3 to position.
        endcase.
      when &apos;&quot;&apos;. &quot;// Finished string
        exit.
      when others.
        append json+position(1) to characters.
    endcase.

    add 1 to position.
  endwhile.
  add 1 to position.

  concatenate lines of characters into string respecting blanks.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE" VERSION="1" LANGU="P" DESCRIPT="Codifica um objeto de dados para JSON" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ENCODE.
  &quot;// Encode passed data object to normal JSON
  json = encode_anything(
    name = name
    value = value
  ).

  &quot;// Format generated JSON string
  if json is not initial.
    &quot;// Apply indented style
    if me-&gt;pretty_print is not initial.
      json = pretty_print_json( json ).
    endif.
  else.
    if name is not initial.
      concatenate name &apos;: {}&apos; into json.
    else.
      json = &apos;{}&apos;.
    endif.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE_ANYTHING" VERSION="1" LANGU="P" DESCRIPT="Codifica um objeto de dados genérico para JSON" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_ANYTHING" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_ANYTHING" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_ANYTHING" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ENCODE_ANYTHING.
  data: type type ref to cl_abap_typedescr,
        contents_json type string.

  &quot;// Check if this should be included
  check value is not initial or me-&gt;include_empty_values is not initial.

  &quot;// Get data object type
  type = cl_abap_typedescr=&gt;describe_by_data( value ).

  case type-&gt;type_kind.
    &quot;// Object references
    when cl_abap_typedescr=&gt;typekind_oref.
      json = encode_object(
        name = name
        type = type
        value = value
      ).

    &quot;// Structures
    when cl_abap_typedescr=&gt;typekind_struct1 or
         cl_abap_typedescr=&gt;typekind_struct2.
      json = encode_structure(
        name = name
        type = type
        value = value
      ).

    &quot;// Tables
    when cl_abap_typedescr=&gt;typekind_table.
      json = encode_table(
        name = name
        type = type
        value = value
      ).

    &quot;// Fields
    when others.
      json = encode_field(
        name = name
        type = type
        value = value
      ).
  endcase.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE_FIELD" VERSION="1" LANGU="P" DESCRIPT="Codifica um campo para JSON" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_FIELD" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_FIELD" SCONAME="TYPE" VERSION="1" LANGU="P" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_FIELD" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_FIELD" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method encode_field.
  data: formatted_value type string,
        relative_name   type string.

  &quot;// Timestamp? (becomes ISO-8601)
  relative_name = type-&gt;get_relative_name( ).
  if relative_name = &apos;TIMESTAMP&apos;.
    formatted_value = timestamp_sap_to_iso( value ).
  else.
    case type-&gt;type_kind.
        &quot;// Date fields (become ISO-8601)
      when cl_abap_typedescr=&gt;typekind_date.
        formatted_value = date_sap_to_iso( value ).

        &quot;// Time fields (become ISO-8601)
      when cl_abap_typedescr=&gt;typekind_time.
        formatted_value = time_sap_to_iso( value ).

        &quot;// Static fields (don&apos;t need conversion)
      when cl_abap_typedescr=&gt;typekind_num or
           cl_abap_typedescr=&gt;typekind_hex or
           cl_abap_typedescr=&gt;typekind_string or
           cl_abap_typedescr=&gt;typekind_xstring.
        formatted_value = value.

        &quot;// Numeric fields
      when cl_abap_typedescr=&gt;typekind_packed or
           cl_abap_typedescr=&gt;typekind_float or
           cl_abap_typedescr=&gt;typekind_int or
           cl_abap_typedescr=&gt;typekind_int1 or
           cl_abap_typedescr=&gt;typekind_int2 or
           cl_abap_typedescr=&gt;typekind_numeric.
        formatted_value = value.
        translate formatted_value using &apos;- + &apos;.
        condense formatted_value no-gaps.
        if value &lt; 0.
          concatenate &apos;-&apos; formatted_value into formatted_value.
        endif.

        &quot;// Anything else gets the default SAP output conversion
      when others.
        formatted_value = value.
        if me-&gt;use_conversion_exits is not initial.
          call_conversion_exit(
            exporting direction = 1
                      type = type
                      value = value
            changing result = formatted_value
          ).
        endif.

    endcase.
  endif.
  formatted_value = escape_string( formatted_value ).

  &quot;// Build JSON string
  if me-&gt;lowercase_names is not initial.
    translate name to lower case.
  endif.
  concatenate &apos;&quot;&apos; name &apos;&quot;: &quot;&apos; formatted_value &apos;&quot;&apos; into json.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE_OBJECT" VERSION="1" LANGU="P" DESCRIPT="Codifica um objeto ABAP para JSON" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_OBJECT" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_OBJECT" SCONAME="TYPE" VERSION="1" LANGU="P" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_OBJECT" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_OBJECT" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ENCODE_OBJECT.
  data: ref type ref to cl_abap_refdescr,
        obj type ref to cl_abap_objectdescr,
        attributes_json type table of string,
        attribute_name type string,
        json_line type string.

  field-symbols: &lt;attribute_descr&gt; like line of obj-&gt;attributes,
                 &lt;attribute&gt; type any.

  &quot;// Encode all obj attributes
  ref ?= type.
  obj ?= ref-&gt;get_referenced_type( ).

  loop at obj-&gt;attributes assigning &lt;attribute_descr&gt;
      where visibility = cl_abap_classdescr=&gt;public.
    concatenate &apos;value-&gt;&apos; &lt;attribute_descr&gt;-name into attribute_name.
    assign (attribute_name) to &lt;attribute&gt;.
    if sy-subrc = 0.
      json_line = encode_anything(
        name = &lt;attribute_descr&gt;-name
        value = &lt;attribute&gt;
      ).
      if json_line is not initial.
        append json_line to attributes_json.
      endif.
    endif.
  endloop.

  &quot;// Build JSON string
  concatenate lines of attributes_json into json
    separated by &apos;,&apos;.
  if name is not initial.
    if me-&gt;lowercase_names is not initial.
      translate name to lower case.
    endif.
    concatenate &apos;&quot;&apos; name &apos;&quot;: {&apos; json &apos;}&apos; into json.
  else.
    concatenate &apos;{&apos; json &apos;}&apos; into json.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE_STRUCTURE" VERSION="1" LANGU="P" DESCRIPT="Codifica uma estrutura para JSON" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_STRUCTURE" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_STRUCTURE" SCONAME="TYPE" VERSION="1" LANGU="P" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_STRUCTURE" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_STRUCTURE" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ENCODE_STRUCTURE.
  data: struct type ref to cl_abap_structdescr,
        fields_json type table of string,
        field_name type string,
        json_line type string.

  field-symbols: &lt;component&gt; like line of struct-&gt;components,
                 &lt;field&gt; type any.

  &quot;// Encode all class attributes
  struct ?= type.

  loop at struct-&gt;components assigning &lt;component&gt;.
    assign component &lt;component&gt;-name of structure value
      to &lt;field&gt;.
    if sy-subrc = 0.
      json_line = encode_anything(
        name = &lt;component&gt;-name
        value = &lt;field&gt;
      ).
      if json_line is not initial.
        append json_line to fields_json.
      endif.
    endif.
  endloop.

  &quot;// Build JSON string
  concatenate lines of fields_json into json
    separated by &apos;,&apos;.
  if name is not initial.
    if me-&gt;lowercase_names is not initial.
      translate name to lower case.
    endif.
    concatenate &apos;&quot;&apos; name &apos;&quot;: {&apos; json &apos;}&apos; into json.
  else.
    concatenate &apos;{&apos; json &apos;}&apos; into json.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ENCODE_TABLE" VERSION="1" LANGU="P" DESCRIPT="Codifica uma tabela para JSON" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_TABLE" SCONAME="NAME" VERSION="1" LANGU="P" DESCRIPT="Nome do objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_TABLE" SCONAME="TYPE" VERSION="1" LANGU="P" DESCRIPT="Runtime Type Services" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="CL_ABAP_TYPEDESCR"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_TABLE" SCONAME="VALUE" VERSION="1" LANGU="P" DESCRIPT="Objeto de dados" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ENCODE_TABLE" SCONAME="JSON" VERSION="1" LANGU="P" DESCRIPT="String JSON" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ENCODE_TABLE.
  data: table type ref to cl_abap_tabledescr,
        lines_json type table of string,
        json_line type string.

  field-symbols: &lt;table&gt; type any table,
                 &lt;line&gt; type any.

  &quot;// Encode all table lines
  table ?= type.

  assign value to &lt;table&gt;.
  loop at &lt;table&gt; assigning &lt;line&gt;.
    json_line = encode_anything(
      value = &lt;line&gt;
    ).
    if json_line is not initial.
      append json_line to lines_json.
    endif.
  endloop.

  &quot;// Build JSON string
  concatenate lines of lines_json into json
    separated by &apos;,&apos;.
  if name is not initial.
    if me-&gt;lowercase_names is not initial.
      translate name to lower case.
    endif.
    concatenate &apos;&quot;&apos; name &apos;&quot;: [&apos; json &apos;]&apos; into json.
  else.
    concatenate &apos;[&apos; json &apos;]&apos; into json.
  endif.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="ESCAPE_STRING" VERSION="1" LANGU="P" DESCRIPT="Converte um valor para um formato escapado" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ESCAPE_STRING" SCONAME="INPUT" VERSION="1" LANGU="P" DESCRIPT="Entrada" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="ESCAPE_STRING" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="String escapada" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method ESCAPE_STRING.
  data: cr type c,
        lf type c.

  field-symbols &lt;x&gt; type x.

  assign cr to &lt;x&gt; casting. &lt;x&gt; = 13.
  assign lf to &lt;x&gt; casting. &lt;x&gt; = 10.

  result = input.
  replace regex &apos;\s+$&apos; in result with &apos;&apos;.
  replace all occurrences of &apos;\&apos; in result with &apos;\\&apos;.
  replace all occurrences of cr in result with &apos;\r&apos;.
  replace all occurrences of lf in result with &apos;\n&apos;.
  replace all occurrences of &apos;&quot;&apos; in result with &apos;\&quot;&apos;.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="PRETTY_PRINT_JSON" VERSION="1" LANGU="P" DESCRIPT="Formata uma string JSON para um formato indentado." EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="PRETTY_PRINT_JSON" SCONAME="JSON_IN" VERSION="1" LANGU="P" DESCRIPT="String JSON de entrada" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="PRETTY_PRINT_JSON" SCONAME="JSON_OUT" VERSION="1" LANGU="P" DESCRIPT="String JSON de saída" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method PRETTY_PRINT_JSON.
  data: input_length type i,
        input_pos type i,
        prev_input_char type c,
        input_char type c,
        next_input_pos type i,
        next_input_char type c,
        in_string type flag,
        skip_chars type i,
        result_pos type i,
        indent_level type i,
        start_new_line_before type flag,
        start_new_line_after type flag,
        result type table of string,
        result_line(1024) type c.

  &quot;// Go through the input string and ident it, creating a line table
  input_length = strlen( json_in ).
  do input_length times.
    input_char = json_in+input_pos(1).
    next_input_pos = input_pos + 1.
    if next_input_pos &lt; input_length.
      next_input_char = json_in+next_input_pos(1).
    else.
      clear next_input_char.
    endif.

    if skip_chars = 0.
      case input_char.
        &quot;// Escaped character
        when &apos;\&apos;.
          skip_chars = 1.
          if next_input_char = &apos;u&apos;.
            skip_chars = 5.
          endif.

        &quot;// String
        when &apos;&quot;&apos;.
          if in_string is initial.
            in_string = &apos;X&apos;.
          else.
            clear in_string.
          endif.

        &quot;// Opening blocks
        when &apos;{&apos; or &apos;[&apos;.
          if in_string is initial.
            add 1 to indent_level.
            if next_input_char &lt;&gt; &apos;}&apos; and
               next_input_char &lt;&gt; &apos;]&apos;.
              start_new_line_after = &apos;X&apos;.
            endif.
          endif.

        &quot;// Closing blocks
        when &apos;}&apos; or &apos;]&apos;.
          if in_string is initial.
            subtract 1 from indent_level.
            if prev_input_char &lt;&gt; &apos;{&apos; and
               prev_input_char &lt;&gt; &apos;[&apos;.
              start_new_line_before = &apos;X&apos;.
            endif.
          endif.

        &quot;// Between members
        when &apos;,&apos;.
          if in_string is initial.
            start_new_line_after = &apos;X&apos;.
          endif.
      endcase.
    else.
      subtract 1 from skip_chars.
    endif.

    if start_new_line_before is not initial.
      clear start_new_line_before.
      append result_line to result.
      clear result_line.
      result_pos = indent_level * 2.
    endif.

    result_line+result_pos = input_char.
    add 1 to result_pos.

    if start_new_line_after is not initial.
      clear start_new_line_after.
      append result_line to result.
      clear result_line.
      result_pos = indent_level * 2.
    endif.

    prev_input_char = input_char.
    input_pos = next_input_pos.
  enddo.
  append result_line to result.

  &quot;// Glue the lines together
  concatenate lines of result into json_out
    separated by %_cr_lf.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_ISO_TO_SAP" VERSION="1" LANGU="P" DESCRIPT="Converte um timestamp ISO-8601 para o formato SAP" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_ISO_TO_SAP" SCONAME="TIMESTAMP" VERSION="1" LANGU="P" DESCRIPT="Data/hora em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_ISO_TO_SAP" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Timestamp SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMESTAMP"/>
  <source>method TIMESTAMP_ISO_TO_SAP.
  data: date_iso type string,
        time_iso type string,
        tsc(14) type c.

  split timestamp at &apos;T&apos; into date_iso time_iso.
  check sy-subrc = 0.

  tsc(8) = date_iso_to_sap( date_iso ).
  tsc+8(6) = time_iso_to_sap( time_iso ).
  result = tsc.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_SAP_TO_ISO" VERSION="1" LANGU="P" DESCRIPT="Converte um timestamp SAP para o formato ISO-8601" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_SAP_TO_ISO" SCONAME="TIMESTAMP" VERSION="1" LANGU="P" DESCRIPT="Registro da hora UTC em forma breve (AAAAMMDDhhmmss)" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMESTAMP"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIMESTAMP_SAP_TO_ISO" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Data/hora em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method TIMESTAMP_SAP_TO_ISO.
  data: begin of ts_split,
          date type datum,
          time type uzeit,
        end of ts_split,
        tsc(14) type n,
        date_iso type string,
        time_iso type string.

  ts_split = tsc = timestamp.
  date_iso = date_sap_to_iso( ts_split-date ).
  time_iso = time_sap_to_iso( ts_split-time ).

  concatenate date_iso &apos;T&apos; time_iso into result.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="TIME_ISO_TO_SAP" VERSION="1" LANGU="P" DESCRIPT="Converte uma hora ISO-8601 para o formato SAP" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIME_ISO_TO_SAP" SCONAME="TIME" VERSION="1" LANGU="P" DESCRIPT="Hora SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="CLIKE"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIME_ISO_TO_SAP" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Hora em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMS"/>
  <source>method TIME_ISO_TO_SAP.
  data: hour(2) type n,
        min(2) type n,
        sec(2) type n.

  &quot;// ISO-8601 allowed formats:
  &quot;//  hh:mm:ss or hh:mm or hhmmss or hhmm or hh
  find regex &apos;(\d{2}):?(\d{2})?:?(\d{2})?&apos; in time
    submatches hour min sec.

  concatenate hour min sec into result.
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON" CMPNAME="TIME_SAP_TO_ISO" VERSION="1" LANGU="P" DESCRIPT="Converte uma hora SAP para o formato ISO-8601" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIME_SAP_TO_ISO" SCONAME="TIME" VERSION="1" LANGU="P" DESCRIPT="Hora SAP" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="TIMS"/>
  <parameter CLSNAME="ZCL_JSON" CMPNAME="TIME_SAP_TO_ISO" SCONAME="RESULT" VERSION="1" LANGU="P" DESCRIPT="Hora em formato ISO-8601" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method TIME_SAP_TO_ISO.
  concatenate time(2) &apos;:&apos; time+2(2) &apos;:&apos; time+4(2) into result.
endmethod.</source>
 </method>
</CLAS>
